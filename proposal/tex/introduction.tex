\section{Introduction}

Until recently, the speed of the processors was expected to increase rapidly over time with sustained technology advances, and the motivation for parallel computing was low. But now, clock frequencies for individual processors are no longer increasing. The reason for that being the power consumed by a processor using current device technologies varies as the cube of the frequency. Processor chips in laptop and personal computers are typically limited to consume at most 75 Watts because a larger power consumption would lead to chips overheating and malfunctioning, given the limited air­cooling capacity of these computers. This power limitation has been referred to as the “Power Wall”. The Power Wall is even more critical in smart­phones and hand held devices because larger power consumption leads to a shorter battery life. Therefore, clock frequency can no longer be increased. When multiple cores are used in parallel, the speed of computation is increased but not the power consumption. This is the main motivation behind parallel programming.

 However, the introduction of concurrency in programs leads to non deterministic behavior. Many problems such as deadlocks, data races etc. arise when concurrent programs are not written correctly. Such issues are very hard to debug.
 
 Many tools have been developed to detect deadlocks, data races, non-determinism in parallel programs. These tools assist the developers of concurrent programs to detect erroneous behavior of their programs and rectify their implementations. However, in large systems it takes a great deal of effort to locate and rectify such errors. Especially in safety-critical systems, it is very important to ensure that the concurrent programs are free of such errors.
 
The developers are, therefore, trying to develop parallel programming languages that ensure safety against concurrency related errors. Examples of such languages are Habanero Java, Cilk, OpenMP 3.0 etc.  Verification techniques need to be developed to the features of these languages. The research proposed here discusses a new way of verification of task parallel programming languages with the help of computation graphs. A computation graph of a program represents an execution of the program under certain thread-interleavings. A CG is an acyclic directed graph that consists of a set of nodes, where each node represents a step consisting of some sequential execution of the program and a set of edges that represent the ordering of the steps. A CG should store the memory locations accessed and updated by each of the operators. It should also correctly reflect the control flow structure of the program. These properties are necessary for verification algorithms to correctly identify the errors in the programming constructs.

The research plan described here uses Habanero Java language as an exemplar of task-parallel programming languages. The verification technique and algorithms developed in this research can be extended to other task parallel programming languages as well.